# 学习笔记

过程：http -- html parse -- dom css computing -- layout -- render

## 词法分析

html中三种标签：开始标签，结束标签，自封闭标签

解析标签：主要是开始标签，结束标签，自封闭标签的解析

解析完之后，需要创建元素：获取token.在状态迁移到的逻辑中需要加业务逻辑。分析标签的标志，来获取token，采用追加的方式。

处理属性：属性值需要氛围单引号，双引号，无引号三种方法进行处理。处理属性的方式跟标签类似，属性结束时候，把属性还在标签token上。

## 语法分析

构建dom树。使用栈来实现。遇到开始标签时创建元素并入栈，遇到结束标签时出栈

自封闭标签可以视为入栈后立刻出栈，任何元素的父元素是它入栈前的栈顶

然后需要构建文本节点，跟自封闭类似，不会入栈，多个文本节点需要进行合并

## CSS计算

### 收集CSS规则

构建一个带规则的dom树。之前构建的树并没有带css规则。

环境准备：需要一个css parser，npm install css,获取css的ast.使用css parser 来分心css规则，关注parser生成的css规则的格式

收集完之后需要应用规则。要求，分析道startTag的时候，就已经知道该tag可以应用那些规则,创建元素的时候就立即计算css。

获取父元素序列

在computedCSS函数中，必须知道元素的所有父元素才可以判断元素与规则是否匹配。在之前处理的stacki中可以获取到本元素所有的父元素。因为首先获取的是当前元素，所以获得和计算父元素匹配的顺序是从内向外的去匹配。

第四步处理选择器与元素的匹配问题

选择器：有一个层级结构，最外层是选择器列表，已有parser处理，

复杂选择器：有秦代关系。根据空格进行拆分。选择器也要从当前元素向外排列。复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列

第五步：完成match函数，匹配

根据选择器的类型和元素的属性，计算是否与当前元素匹配。

第六步：将computed属性生成。

遍历ast中生成的属性声明，并运用到元素上。这里需要对优先级做处理

specificity：特征，专一性。翻译为专指更准确点。优先级为priority

specifiity是一个四原组：[0, 0, 0, 0]  === [inline, id, class, tagname]

inline：行内，写在标签里头的style样式

对比：[0, 1, 0, 2] < [0, 2, 0, 0] 高位能比较出来，就不会再对比地位，这里第二个id位比第一个id位搞，就不会再对tag位了

这里需要写一个函数来计算specificity。根据specificity来计算。



